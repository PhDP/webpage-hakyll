---
title: A gentle introduction to statistical relational learning: maths, code, and examples
tags: machine learning, artificial intelligence, manticore
---

<p>I won't explain all the details</p>

<table style='width: 80%'>
  <tr>
    <th>Statement</th>
    <th>Weight</th>
  </tr>
  <tr>
    <td>Smoking causes cancers</td>
    <td align='center'>1.1</td>
  </tr>
  <tr>
    <td>If two people are friends and one smokes, then so does the other</td>
    <td align='center'>1.5</td>
  </tr>
</table>

<p>Or using the symbolic representation for logic:</p>

\[\forall x: Smoking(x) \Rightarrow Cancer(x), 1.5;\]
\[\forall x, y: Friend(x, y) \land Smoking(x) \Rightarrow Smoking(y), 1.1;\]

<p>where \(\forall\) is "for all", \(\land\) is "and", and \(\Rightarrow\) is "implies".</p>

<p>Interpretation of the formulas are really cool... the interpretatin of the
weight is a bit trickier. It's the </p>

<p>Admidittely</p>

<h2>Inference in Markov logic</h2>

<p>Where's our network? It's called a Markov logic network, but all we got
is a set of weighted first-order logic formulas. While I do suggest you spread
riots and chaos in anger, there's actually a pretty explanation. A Markov
logic network is a template for Markov networks. Take the formulas</p>

\[\forall x: Smoking(x) \Rightarrow Cancer(x), 1.5;\]

<p>Let's say we are interested smoking/cancer for Anna, Bob, Charlotte, Dominique,
we can apply these constants to the formula to get a set of ground formulas:</p>

\[Smoking(Anna) \Rightarrow Cancer(Anna), 1.5;\]
\[Smoking(Bob) \Rightarrow Cancer(Bob), 1.5;\]
\[Smoking(Charlotte) \Rightarrow Cancer(Charlotte), 1.5;\]

<p>We could do the same thing with the other formula, but now it has two
variables:</p>

\[Friend(Anna, Anna) \land Smoking(Anna) \Rightarrow Smoking(Anna), 1.1;\]
\[Friend(Anna, Bob) \land Smoking(Anna) \Rightarrow Smoking(Bob), 1.1;\]
\[Friend(Anna, Charlotte) \land Smoking(Anna) \Rightarrow Smoking(Charlotte), 1.1;\]
\[Friend(Bob, Anna) \land Smoking(Bob) \Rightarrow Smoking(Anna), 1.1;\]
\[Friend(Bob, Bob) \land Smoking(Bob) \Rightarrow Smoking(Bob), 1.1;\]
\[Friend(Bob, Charlotte) \land Smoking(Bob) \Rightarrow Smoking(Charlotte), 1.1;\]
\[Friend(Charlotte, Anna) \land Smoking(Charlotte) \Rightarrow Smoking(Anna), 1.1;\]
\[Friend(Charlotte, Bob) \land Smoking(Charlotte) \Rightarrow Smoking(Bob), 1.1;\]
\[Friend(Charlotte, Charlotte) \land Smoking(Charlotte) \Rightarrow Smoking(Charlotte), 1.1;\]

<p>From the groundings of the two formulas, we get a set of predicates:</p>

\[\{Smoking(Anna), Smoking(Bob), Smoking(Charlotte), Cancer(Anna), Cancer(Bob),\]

\[Cancer(Charlotte), Friend(Anna, Anna), Friend(Anna, Bob), Friend(Anna, Charlotte),\]

\[Friend(Bob, Anna), Friend(Bob, Bob), Friend(Bob, Charlotte),\]

\[Friend(Charlotte, Anna), Friend(Charlotte, Bob), Friend(Bob, Charlotte)\}\]

<p>Of course, we could generate a completely different set of ground formulas
and ground predicates if we applied, say, the constants \(\{James, Jean-Luc,
Kathryn, Benjamin\}\), or any number of objects we're interested in. Also, we
don't need to have full data on all predicates, I'll show examples where we
have no information at all.</p>

<h2>Manticore</h2>

<p<a href=''>In the last post</a> I discussed the motivation / philosophy behind
statistical relational learning, now it's time for maths &amp; code. If you
want to follow the code in an interactive console, <a href=''>the code is on github</a>.</p>

<p>I wrote it in Haskell for the interactive mode, and <a
  href='http://phdp.github.io/posts/2015-04-05-automated-reasoning.html'> sum
types are particularly powerful for this kind of software</a>. I also have a
bunch of C++/F# code lying around, but it's far less user-friendly.</p>

<p>Right now, it performs only exact inference, which is useful for tests... but it
does not scale (the Markov networks generated by Markov logic are humongous). It'll
be enough for exploring a model.</p>

<h2>Example</h2>

<p>Here's a complete session based on the classic <i>smoking</i> example from
the <a href='https://homes.cs.washington.edu/~pedrod/kbmn.pdf'>paper that
introduced Markov logic</a>.</p>

<p>First, import the Markov logic network module:</p>

<pre><code class="haskell">ghci> import qualified Manticore.MarkovLogic as ML</code></pre>

<p>The most straighforward way to build a Markov logic network is with
<i>fromStrings</i>. This function takes an array of strings, each of which must
be a valid first-order logic formula followed (or preceded) by a number (the
weight of the formula). In this case we have:</p>

<pre><code class="haskell">ghci> let mln = ML.fromStrings ["∀x Smoking(x) ⇒ Cancer(x) 1.5", "∀x∀y Friend(x, y) ∧ Smoking(x) ⇒ Smoking(y) 1.1"]</code></pre>

<p>The strings were copy-pasted from Richardson and Domingos' paper, but the
parsers is flexible and will accept a keyboard-friendly form too:</p>

<pre><code class="haskell">ghci> ML.fromStrings ["1.5 forall x Smoking(x) implies Cancer(x)", "1.1 forall x, y Friend(x, y) and Smoking(x) implies Smoking(y)"]</code></pre>

<p>We can use <i>fmtMLN</i> function to print the Markov logic
network:</p>

<pre><code class="haskell">ghci> putStrLn (fmtMLN mln)
1.5                     ∀x Smoking(x) ⇒ Cancer(x)
1.1                     ∀x ∀y Friend(x, y) ∧ Smoking(x) ⇒ Smoking(y)</code></pre>

<p>A Markov logic network is a template for Markov networks. To get a Markov
network, we need to apply a set of constant to the Markov logic networks
Here, we will create only two constants:</p>

<pre><code class="haskell">ghci> let cs = ["Anna", "Bob"]</code></pre>

<p>Then, we can query the network, say, what is the probability that Anna has
cancer?</p>

<pre><code class="haskell">ghci> ML.ask cs mln "P(Cancer(Anna))"
Just 0.6133819604540808</code></pre>

<p>The function <i>ask</i> takes a Markov logic network, a list
of terms (represented as a list of strings), and a string query. It will return
Just P, with P being a probability in the [0.0, 1.0] range, or Nothing if the
parser fails to read the query. To make the process a bit easier we'll create
a function ask that have already the mln and terms supplied:</p>

<pre><code class="haskell">ghci> let ask = MLN.ask mln cs</code></pre>

Then we can ask queries with this function:

<pre><code class="haskell">ghci> ask "P(Cancer(Anna) and Cancer(Bob))"
Just 0.38061259085226223</code></pre>

<pre><code class="haskell">ghci> ask "P(Cancer(Anna) | Smoking(Bob))"
Just 0.6519697695221907</code></pre>

<pre><code class="haskell">ghci> ask "P(Cancer(Anna) | Smoking(Bob), Friend(Bob, Anna))"
Just 0.7056438194691147</code></pre>

We could write \"Cancer(Anna) = True\", but the parser assumes all predicates
are true if they are not assigned to a value. If we can to say something is
false, say: Anna is not smoking, we could write \"Smoking(Anna) = False\" or
the shorter \"!Smoking(Anna)\"

<pre><code class="haskell">ghci> ask "P(Cancer(Anna) | !Smoking(Anna), Smoking(Bob), Friend(Bob, Anna))"
Just 0.49999999999999994

ghci> ask "P(Cancer(Anna) | !Smoking(Anna), !Smoking(Bob), !Friend(Bob, Anna))"
Just 0.5000000000000002</code></pre>

We can add a logic formula to the network with the 'Manticore.MarkovLogic.tell'
function. Note that 'Manticore.MarkovLogic.tell' takes a string (just like
'Manticore.MarkovLogic.fromStrings' takes a list of strings) and will return
a new Markov logic network with the formula added. Let's say we want to add
a rule that /friends of friends are friends/, we could add this rule with a
weight of 1.0 with:

<pre><code class="haskell">ghci> let mln2 = tell "1.0 A.x,y,z Friend(x, y) and Friend(y, z) => Friend(x, z)" mln
ghci> putStrLn (fmtMLN mln2)
1.5                     ∀x Smoking(x) ⇒ Cancer(x)
1.0                     ∀x ∀y ∀z Friend(x, y) ∧ Friend(y, z) ⇒ Friend(x, z)
1.1                     ∀x ∀y Friend(x, y) ∧ Smoking(x) ⇒ Smoking(y)</code></pre>

This time we'll ask queries with this network using four objects: Anna, Bob,
Charlotte, Dominique, again creating a shortcut function ask2 to avoid always
providing the same arguments:

<pre><code class="haskell">ghci> let cs2 = ["Anna", "Bob", "Charlotte"]
ghci> let ask2 = ML.ask cs2 mln2</code></pre>

<pre><code class="haskell">ghci> ask2 "P(Cancer(Anna))"
Just 0.6093306813995714
ghci> ask2 "P(Cancer(Anna) | Smoking(Bob) and Friend(Bob, Charlotte))"
Just 0.6504904438065744
ghci> ask2 "P(Cancer(Anna) | Smoking(Bob))"
Just 0.6399247839775043
ghci> ask2 "P(Cancer(Anna) | Smoking(Bob) and Friend(Bob, Charlotte) and Friend(Charlotte, Anna))"
Just 0.7070401384366385
ghci> ask2 "P(Cancer(Anna) | Smoking(Bob) and Friend(Bob, Charlotte) and !Friend(Charlotte, Anna))"
Just 0.6329610969479669
ghci> ask2 "P(Cancer(Anna) | Smoking(Bob) and Friend(Bob, Charlotte) and Friend(Charlotte, Anna) and !Smoking(Anna))"
Just 0.4999999999999977
ghci> ask2 "P(Cancer(Anna) | !Smoking(Anna))"
Just 0.49999999999999856</code></pre>

\[\forall Friend(x, y) \iff Friend(y, x), w;\]

