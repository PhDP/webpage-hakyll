---
title: A crash course in first-order logic
tags: machine learning, artificial intelligence, manticore
---

<p>This is a short but complete description of first-order logic, a rich system
to reason about objects and their relationships. I care mostly about
first-order logic for its role in statistical relational learning (a branch of
machine learning), which I'll cover in another post. Here, I just describe
logic. If you want a more detailed explanation, see <a
href='http://aima.cs.berkeley.edu/'>Russell and Norvig excellent A.I.
book.</a></p>

<h2>Terms</h2>

<p>Terms represent objects and relationships between objects, they are the
reason why logic is so flexible. There are three types of terms:</p>

<ol type='I'>
  <li><b>Constants</b> represent objects, e.g.: <i>Tokyo</i>, the number <i>47</i>, <i>Cylon</i>, <i>Lion</i>.</li>
  <li><b>Variables</b> range over objects, e.g. the variable <i>c</i> could represent a city, <i>x</i> an integer, <i>s</i> a species. By convention, variables start with a lowercase character.</li>
  <li><b>Functions</b> are mappings between a list of objects to another object, e.g. <i>CapitalOf</i> could take a country and return a city, while <i>Multiply</i> takes two numbers and returns a number. The number of arguments taken a function is called its arity.</li>
</ol>

<p>Examples:</p>

\[Add(x, 5)\]

<p>Add is a function taking two numbers and returning a number, x is a
variable, and 5 is a constant. Since a function is a term, it can be used
within functions:</p>

\[Add(Multiply(x, y), 5)\]

<h2>Atomic sentences</h2>

<p>Logic formulas ultimately resolve to a truth value: True or False, yet the
terms we've seen return objects. To get a truth value, we need predicates. A
predicate is like a function but it maps objects to a truth value, not another
object. For example, if we want to say that adding 0 to a x yields x, we can
write:</p>

<ol style='list-style-type: upper-roman'>
  <li><b>True</b> or <i>top</i>: \(\top\), and it's negation <b>False</b> or <i>bottom</i>: \(\bot\).</li>
  <li><b>Predicates</b>, which are mappings between 0 or more <b>terms</b> to a truth value. They have the same form as functions but can be distinguished by the context: predicates are atomic sentences, not functions.</li>
  <li><b>Identity</b>, represented by the mysterious = symbol, tests if two terms are the same. Identity can be (and often is) seen as a predicate with two arguments.</li>
</ol>

\[Equals(Add(x, 0), x)\]
\[Add(x, 0) = x\]

<p><i>Equals</i> is a predicate, in this case it takes two numbers and returns
true or false. We could have a predicate that takes three cities and return
true if they are on the same continent:</p>

\[SameContinent(Toronto, c, CapitalOf(LargestCountryOf(Europe)))\]

<p>where SameContinent is a predicate, Toronto a constant, c a variable ranging
over cities, and both CapitalOf and LargestCountryOf are functions taking a
single argument.</p>

<h2>Connectives</h2>

<p>Atomic sentences are connected by connectives to form complex sentences. The
standard connectives are:</p>

<ol style='list-style-type: upper-roman'>
  <li>The binary connective <b>and</b>: \(x \land y\), which is true only if both \(x\) and \(y\) are true. Like all other connective shown here, if \(x\) and \(y\) are sentences, then \(x \land y\) is also a valid sentence.</li>
  <li>The binary connective <b>or</b>: \(x \lor y\), which is true only if \(x\) is true, if \(y\) is true, or if both are true.</li>
  <li>The binary connective <b>implies</b>: \(x \Rightarrow y\), returns true in all cases, except if \(x\) is true and \(y\) is false.</li>
  <li>The binary connective <b>iff</b>: \(x \leftrightarrow y\), returns true if \(x\) and \(y\) have the same value, that is if they are both true, or both false.</li>
  <li>The binary connective <b>xor</b> (exclusive or): \(x \oplus y\), returns true if \(x\) and \(y\) have different values.</li>
  <li>The unary connective <b>not</b>: \(\lnot x\), which is true only if \(x\) is false.</li>
</ol>

<p>Be careful with implication, there is nothing wrong with it, except that it
doesn't fit how we use the term <i>implies</i>. For example:
\(Equals(AgeOf(Earth), 42) \implies StillAlive(Elvis)\) is true. If you're
confused, read again the description of <b>implies</b>.</p>

<p>Before we see examples, we'll look at the last element we need to complete
the language of first-order logic<./p>

<h2>Qualifiers</h2>

<p>There are two qualifiers in first-order logic: the universal qualifiers "for
all" denoted \(\forall\) , and the existential qualifiers "exists" denoted
\(\exists\)). They, well, qualify variables, e.g.:</p>

\[\forall x: Multiply(x, 0) = 0,\]

<p>means: for all x, multiplying x by 0 yields 0. Normally, all variables
should be qualified to determine their scope, e.g.:</p> 

\[\forall x \exists y: GreaterThan(y, x)\]

<p>which means, for all number x, there is a number y that is greater than x.
If we had just</p>

\[\forall x, y: GreaterThan(y, x)\]

<p>that would be obviously wrong (say, for x = 3 and y = 1).</p>

\[\forall y \exists c: IsWhite(y) \lor BritherThan(x, y).\]

<p>Either x is white, or there is a color y brighter than it.</p>

\[\exists c: CapitalOf(c) = Tokyo.\]

\[\exists s: NumberOfPredators(s) = 0.\]

<p>Again, remember the = is basically just syntactic sugar for a predicate, we could write:</p>

\[\exists s: Equals(NumberOfPredators(s), 0).\]

\[PredatorOf(x, y) \land \lnot Parasite(x) \Rightarrow BiggerThan(x, y),\]
\[Friend(x, y) \iff Friend(y, x).\]

